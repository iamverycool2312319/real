print('Initializing AC Bypass!')
 
--// Services
local Players = cloneref(game:GetService("Players"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local RunService = cloneref(game:GetService("RunService"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Teams = cloneref(game:GetService("Teams"))
local TweenService = cloneref(game:GetService("TweenService"))
local Stats = cloneref(game:GetService("Stats"))
local RunService = cloneref(game:GetService("RunService"))
 
if game.PlaceId ~= 8206123457 or game.PlaceId == 8204899140 then
    --> Made by Unlimited, Modified/Updated by NG/Johan Peterson
 
    --// Services
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
    --// Variables
    local Player = game:GetService("Players").LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local HRP = Character and Character.HumanoidRootPart
    local Hooks = {}
    local HandshakeArgs = nil
    local Remote = ReplicatedStorage:WaitForChild("Remotes").CharacterSoundEvent
    local ACString = nil
 
    --> os.clock hook
    local RandomNumber = math.random(1e3, 1e5)
 
    Hooks.Clock = hookfunction(os.date, function(...)
        return Hooks.Clock(...) + RandomNumber
    end)
 
    --> namecall hook
    Hooks.Namecall = hookmetamethod(game, "__namecall", function(self, ...)
        local Method = getnamecallmethod()
        local Args = {...}
 
        if not checkcaller() and self == Remote and (Method == "FireServer" or Method == "fireServer") and string.find(Args[1], "AC") then
            if not HandshakeArgs then
                if type(Args[2]) == "table" and #Args[2] == 19 then
                    ACString = Args[1]
                    HandshakeArgs = Args[2]
                end
            else
                return coroutine.yield()
            end
        end
 
        return Hooks.Namecall(self, ...)
    end)
 
    while not ACString and not HandshakeArgs do
        task.wait()
    end
 
    print("Found handshake arguments.")
 
    task.wait(3)
 
    for i, v in pairs(getgc()) do
        if type(v) == "function" then
            if getinfo(v).source:find("PlayerModule.LocalScript") then
                hookfunction(v, function() end)
            end
        end
    end
 
    print("Hooked all anticheat functions.")
 
    local ReplicateHandshake = function()
        return Remote:fireServer(ACString, HandshakeArgs, nil)
    end
 
    task.spawn(function()
        while task.wait(0.4) do
            local Success, Error = pcall(ReplicateHandshake)
 
            if not Success or Error then
                return {
                    warn("Bypass timed out."),
                    task.wait(20),
                    game:GetService("Players").LocalPlayer:Kick("Bypass timed out.")
                }
            end
        end
    end)
 
    print("Replicated handshake.")
end
 
task.wait()
 
print('Done! Now Loading')



local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
	Name = "SaturnHub PC (BETA)",
	LoadingTitle = "SaturnHub PC",
	LoadingSubtitle = "by SaturnHub Devs",
	ConfigurationSaving = {
		Enabled = true,
		FileName = "Big Hub"
	},
	KeySystem = false, -- Set this to true to use our key system
	KeySettings = {
		Title = "Sirius Hub",
		Subtitle = "Key System",
		Note = "Join the discord (discord.gg/sirius)",
		Key = "ABCDEF"
	}
})
local Tab = Window:CreateTab("QB Stuff")
local Tab1 = Window:CreateTab("Catching")
local Tab2 = Window:CreateTab("Movement")
local Tab3 = Window:CreateTab("Kicker Aimbot")
local Tab4 = Window:CreateTab("Defense stuff")
local Tab5 = Window:CreateTab("Offense stuff")
local Section = Tab:CreateSection("QB")
local Section = Tab1:CreateSection("Mag")
local Section = Tab2:CreateSection("Movement")
local Section = Tab3:CreateSection("Kicking")
local Section = Tab4:CreateSection("Defense")
local Section = Tab5:CreateSection("Offense")
local Label = Tab:CreateLabel("QB stuff in beta be careful!")
local Button = Tab:CreateButton({
	Name = "do this for qb gui to go away",
	Callback = function()
        enabled = false
		-- The function that takes place when the button is pressed
	end,
})


--slider
local Toggle = Tab:CreateToggle({
	Name = "qb aimbot look at top right for the gui",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(state)
      enabled = true
    local leadDistance = 5
    task.spawn(function()
        --// qb gui initalization
        local gui; do
    --AIMCARD
            local AimCard = Instance.new("ScreenGui")
            local Angle = Instance.new("Frame")
            local AngleCorner = Instance.new("UICorner")
            local AngleNum = Instance.new("TextLabel")
            local NumCorn = Instance.new("UICorner")
            local AngleLabel = Instance.new("TextLabel")
            local LabelCorner = Instance.new("UICorner")
            local Player = Instance.new("Frame")
            local PlayerCorn = Instance.new("UICorner")
            local PlayerText = Instance.new("TextLabel")
            local NumCorn2 = Instance.new("UICorner")
            local PlayerLabel = Instance.new("TextLabel")
            local LabelCorner2 = Instance.new("UICorner")
            local Mode = Instance.new("Frame")
            local Modecorn = Instance.new("UICorner")
            local ModeText = Instance.new("TextLabel")
            local NumCorn3 = Instance.new("UICorner")
            local ModeLabel = Instance.new("TextLabel")
            local LabelCorner3 = Instance.new("UICorner")
            
            -- Properties
            
            AimCard.Parent =gethui()
            AimCard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            

            local elementWidth = 100 -- Assuming all elements have the same width


            Angle.Name = "Angle"
            Angle.Parent = AimCard
            Angle.BackgroundColor3 = Color3.new(0.156863, 0.156863, 0.156863)
            Angle.BorderColor3 = Color3.new(0, 0, 0)
            Angle.BorderSizePixel = 0
            Angle.Position = UDim2.new(1, -elementWidth * 3, 0, 0) -- Positioned next to Player
            Angle.Size = UDim2.new(0, elementWidth, 0, 100)
            Angle.ZIndex = 7
            
            AngleCorner.Name = "AngleCorner"
            AngleCorner.Parent = Angle
            
            AngleNum.Name = "AngleNum"
            AngleNum.Parent = Angle
            AngleNum.BackgroundColor3 = Color3.new(1, 1, 1)
            AngleNum.BackgroundTransparency = 1
            AngleNum.BorderColor3 = Color3.new(0, 0, 0)
            AngleNum.BorderSizePixel = 0
            AngleNum.Size = UDim2.new(0, 100, 0, 72)
            AngleNum.Font = Enum.Font.Gotham
            AngleNum.Text = "40"
            AngleNum.TextColor3 = Color3.new(0.8, 0.6, 1)
            AngleNum.TextScaled = true
            AngleNum.TextSize = 14 -- Adjust as needed
            AngleNum.TextWrapped = true
            
            NumCorn.Name = "NumCorn"
            NumCorn.Parent = AngleNum
            
            AngleLabel.Name = "AngleLabel"
            AngleLabel.Parent = Angle
            AngleLabel.BackgroundColor3 = Color3.new(1, 1, 1)
            AngleLabel.BackgroundTransparency = 1
            AngleLabel.BorderColor3 = Color3.new(0, 0, 0)
            AngleLabel.BorderSizePixel = 0
            AngleLabel.Position = UDim2.new(0.025, 0, 0.66, 0)
            AngleLabel.Size = UDim2.new(0, 100, 0, 34)
            AngleLabel.Font = Enum.Font.Gotham
            AngleLabel.Text = "tap f and r "
            AngleLabel.TextColor3 = Color3.new(0.678431, 0.847059, 0.901961)
            AngleLabel.TextSize = 22
            
            LabelCorner.Name = "LabelCorner"
            LabelCorner.Parent = AngleLabel
            
            Player.Name = "Player"
            Player.Parent = AimCard
            Player.BackgroundColor3 = Color3.new(0.156863, 0.156863, 0.156863)
            Player.BorderColor3 = Color3.new(0, 0, 0)
            Player.BorderSizePixel = 0
            Player.Position = UDim2.new(1, -elementWidth, 0, 0) -- Positioned next to Mode
            Player.Size = UDim2.new(0, elementWidth, 0, 100)
            Player.ZIndex = 7
            
            PlayerCorn.Name = "PlayerCorn"
            PlayerCorn.Parent = Player
            
            PlayerText.Name = "PlayerText"
            PlayerText.Parent = Player
            PlayerText.BackgroundColor3 = Color3.new(1, 1, 1)
            PlayerText.BackgroundTransparency = 1
            PlayerText.BorderColor3 = Color3.new(0, 0, 0)
            PlayerText.BorderSizePixel = 0
            PlayerText.Size = UDim2.new(0, 100, 0, 72)
            PlayerText.Font = Enum.Font.Gotham
            PlayerText.Text = "playaa"
            PlayerText.TextColor3 = Color3.new(1, 1, 1)
            PlayerText.TextScaled = true
            PlayerText.TextSize = 1
            PlayerText.TextWrapped = true
            
            NumCorn2.Name = "NumCorn2"
            NumCorn2.Parent = PlayerText
            
            PlayerLabel.Name = "PlayerLabel"
            PlayerLabel.Parent = Player
            PlayerLabel.BackgroundColor3 = Color3.new(1, 1, 1)
            PlayerLabel.BackgroundTransparency = 1
            PlayerLabel.BorderColor3 = Color3.new(0, 0, 0)
            PlayerLabel.BorderSizePixel = 0
            PlayerLabel.Position = UDim2.new(0, 0, 0.660000026, 0)
            PlayerLabel.Size = UDim2.new(0, 100, 0, 34)
            PlayerLabel.Font = Enum.Font.Gotham
            PlayerLabel.Text = "Player press q to lock"
            PlayerLabel.TextColor3 = Color3.new(0.396078, 1, 0.588235)
            PlayerLabel.TextSize = 22
            
            LabelCorner2.Name = "LabelCorner2"
            LabelCorner2.Parent = PlayerLabel


            Mode.Name = "Mode"
            Mode.Parent = AimCard
            Mode.BackgroundColor3 = Color3.new(0.156863, 0.156863, 0.156863)
            Mode.BorderColor3 = Color3.new(0, 0, 0)
            Mode.BorderSizePixel = 0
            Mode.Position = UDim2.new(1, -elementWidth * 2, 0, 0) -- Positioned at the right edge
            Mode.Size = UDim2.new(0, elementWidth, 0, 100)
            Mode.ZIndex = 7
            Modecorn.Name = "Modecorn"
            Modecorn.Parent = Mode
            
            Modecorn.Name = "Modecorn"
            Modecorn.Parent = Mode
            
            ModeText.Name = "ModeText"
            ModeText.Parent = Mode
            ModeText.BackgroundColor3 = Color3.new(1, 1, 1)
            ModeText.BackgroundTransparency = 1
            ModeText.BorderColor3 = Color3.new(0, 0, 0)
            ModeText.BorderSizePixel = 0
            ModeText.Size = UDim2.new(0, 100, 0, 72)
            ModeText.Font = Enum.Font.Gotham
            ModeText.Text = "mag press z to change"
            ModeText.TextColor3 = Color3.new(0.8, 0.6, 1)
            ModeText.TextScaled = true
            ModeText.TextSize = 1
            ModeText.TextWrapped = true
            
            NumCorn3.Name = "NumCorn3"
            NumCorn3.Parent = ModeText
            
            ModeLabel.Name = "ModeLabel"
            ModeLabel.Parent = Mode
            ModeLabel.BackgroundColor3 = Color3.new(1, 1, 1)
            ModeLabel.BackgroundTransparency = 1
            ModeLabel.BorderColor3 = Color3.new(0, 0, 0)
            ModeLabel.BorderSizePixel = 0
            ModeLabel.Position = UDim2.new(0, 0, 0.660000026, 0)
            ModeLabel.Size = UDim2.new(0, 100, 0, 34)
            ModeLabel.Font = Enum.Font.Gotham
            ModeLabel.Text = "Mode"
            ModeLabel.TextColor3 = Color3.new(0.396078, 1, 0.588235)
            ModeLabel.TextSize = 22
            
            LabelCorner3.Name = "LabelCorner3"
            LabelCorner3.Parent = ModeLabel
            
            gui = AimCard
        end
        --// main
        local modes = {
            ["Perfect mag"] = "Bullet",
            ["Bullet"] = "Perfect mag"
        }
        local players = game:GetService("Players")
        local runService = game:GetService("RunService")
        local userInputService = game:GetService("UserInputService")
        local replicatedStorage = game:GetService("ReplicatedStorage")
        local player = players.LocalPlayer
        local angle = 40
        local target = nil
        local locked = false
        local realpower = 0
        local camera = workspace.CurrentCamera
        local highlight = Instance.new("Highlight")
        local sphere = Instance.new("Part")
        local upower, udirection = 0, Vector3.new(0, 0, 0)
        local mouse = loadstring(game:HttpGet("https://raw.githubusercontent.com/vFishyTurtle/UI-Libraries/main/Apple%20Library/a"))()
        local mouseRaycastParams = RaycastParams.new()	
        local usePart = Instance.new("Part")
        usePart.Anchored = true
        usePart.CanCollide = false
        usePart.Size = Vector3.new(2048, 1, 2048)
        usePart.Transparency = 1
        usePart.Parent = workspace
        usePart.Position = player.Character.HumanoidRootPart.Position - Vector3.new(0, 2, 0)
        mouseRaycastParams.FilterType = Enum.RaycastFilterType.Include
        mouseRaycastParams.FilterDescendantsInstances = {usePart}
        mouse:SetRaycastParams(mouseRaycastParams)
    --beam
        local function getMoveDirection(target)
            if players:GetPlayerFromCharacter(target) then
                return target.Humanoid.MoveDirection
            else
                return (target.Humanoid.WalkToPoint - target.Head.Position).Unit
            end
        end
    
        local function findPower(pos)
            local powerTable = {
                [10] = 55,
                [20] = 60,
                [30] = 65,
                [35] = 70,
                [40] = 75,
                [50] = 80,
                [60] = 85,
                [70] = 90,
                [80] = 95,
            }
            local distance = (player.Character.Head.Position - pos).Magnitude
            local lDiff = math.huge
            local power = 0
            local pdistance = nil
            local reachedDis = 0
            local nextDis = 0
            local naturalPower = 0
            for dis, pwr in pairs(powerTable) do
                dis *= 3
                if distance > dis and dis > reachedDis then
                    power = pwr
                    naturalPower = pwr
                    pdistance = dis
                    reachedDis = dis
                    if dis == 90 then nextDis = dis + 15 else nextDis = dis + 30 end
                end
            end
            local diff = math.clamp(nextDis - distance, 0, math.huge)
            local required = (nextDis - reachedDis)
            local nextPower = powerTable[nextDis / 3] or 75
            local percentage = diff / required
            --print(diff, required, nextPower, power, percentage, (nextPower - power) - ((nextPower - power) * percentage))
            power += math.clamp((nextPower - power) - ((nextPower - power) * percentage), 0, 100)
            if power ~= power then
                power = 50
            end
            return power - 5, naturalPower - 5
        end
    
        local function calculateVelocity(x0, d0, t)
            local g = Vector3.new(0, -28, 0)
            local v0 = (d0 - x0 - 0.5*g*t*t)/t;
            local dir = ((x0 + v0) - x0).Unit
            local power = v0.Y / dir.Y
            return v0, dir, power
        end
--qb    
        local function findtarget()
            local np = nil
            local nm = math.huge
            local s = {workspace}
            if workspace:FindFirstChild("npcwr") then
                table.insert(s, workspace.npcwr.a)
                table.insert(s, workspace.npcwr.b)
            end
            for i, p in pairs(s) do
                for i, c in pairs(p:GetChildren()) do
                    if c:FindFirstChildWhichIsA("Humanoid") and c:FindFirstChild("HumanoidRootPart") then
                        local plr = players:GetPlayerFromCharacter(c)
                        if plr == player then continue end
                        if not plr and game.PlaceId ~= 8206123457 then continue end
                        if not player.Neutral then
                            if plr.Team ~= player.Team then
                                continue
                            end
                        end
                        local d = (c.HumanoidRootPart.Position - mouse.Hit.Position).Magnitude
                        if d < nm then
                            nm = d
                            np = c
                        end	
                    end
                end
            end
            return np
        end
    
        local function methodIsA(self, method)
            return string.lower(self) == string.lower(method)
        end
    
        local remotes = {Fake = {}}
    
        local function spoofRemote(remote, funcOnFire)
            local fakeSelf = remote:Clone()
            fakeSelf.Parent = remote.Parent
            remote.Name = ""
            remotes[remote] = funcOnFire
            remotes.Fake[fakeSelf] = remote
        end
    
        local __namecall; __namecall = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()
            if methodIsA(method, "FireServer") and not checkcaller() and remotes.Fake[self]  then
                remotes.Fake[self]:FireServer(remotes[remotes.Fake[self]](...))
            end
            return __namecall(self, ...)
        end)
    
        local function hookFootball(fb)
            local ls = fb.Handle:WaitForChild("LocalScript", 1)
            if ls then
                ls.Enabled = false
                local remoteEvent = fb.Handle:FindFirstChild("RemoteEvent")
                if remoteEvent then
                    spoofRemote(remoteEvent, function(old)
                        local args = {old}
                        if args[1] == "Clicked" then
                            if enabled then
                                return unpack({"Clicked", player.Character.Head.Position, player.Character.Head.Position + (udirection * 10000), (game.PlaceId == 8206123457 and upower) or 61, (game.PlaceId ~= 8206123457 and upower) or nil})
                            else
                                local direction = (player:GetMouse().Hit.Position - camera.CFrame.Position).Unit
                                return unpack({"Clicked", player.Character.Head.Position, player.Character.Head.Position + (direction * 10000), (game.PlaceId == 8206123457 and realpower) or 61, realpower})
                            end
                        else
                            return old
                        end
                    end)
                    fb:WaitForChild("Handle"):WaitForChild("LocalScript").Enabled = true
                end
                ls.Enabled = true
            end
        end
    
        player.Character.ChildAdded:Connect(function(fb)
            if fb:IsA("Tool") then
                fb:WaitForChild("Handle")
                hookFootball(fb)
            end
        end)
    --lock
    userInputService.InputBegan:Connect(function(input, gp)
        if input.KeyCode == Enum.KeyCode.X then
            if gui.Mode.ModeText.Text == "Bullet" then
                angle = 35
                gui.Mode.ModeText.Text = "Dime"
                leadDistance = 8.5
            elseif gui.Mode.ModeText.Text == "Dime" then
                angle = 25
                gui.Mode.ModeText.Text = "Jump"
                leadDistance = 10
            elseif gui.Mode.ModeText.Text == "Jump" then
                angle = 20
                gui.Mode.ModeText.Text = "slant deep"
                leadDistance = 1
            elseif gui.Mode.ModeText.Text == "slant deep" then
                angle = 55
                gui.Mode.ModeText.Text = "Mag"
                leadDistance = 7
            else
                angle = 15
                gui.Mode.ModeText.Text = "Bullet"
                leadDistance = 8
            end
            -- Update GUI
            gui.Angle.AngleNum.Text = angle
            print("Mode changed to:", gui.Mode.ModeText.Text, "Angle:", angle, "Lead Distance:", leadDistance)
        elseif input.KeyCode == Enum.KeyCode.Q then
            locked = not locked
            print("Locked:", locked)
        end
    end)
    
        local function calculateLanding(power, direction)
            local vel = power * direction
            local origin = player.Character.Head.Position + direction * 5
            local peakTime = vel.Y / 28
            return origin + Vector3.new(vel.X * peakTime * 2, 0, vel.Z * peakTime * 2)	
        end
    
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = Color3.fromRGB(255, 0, 0)
        line.Thickness = 1
    
        sphere.Size = Vector3.new(2, 2, 2)
        sphere.Material = Enum.Material.ForceField
        sphere.Anchored = true
        sphere.CanCollide = false
        sphere.Color = Color3.fromRGB(255, 0, 0)
        sphere.Parent = workspace
        highlight.FillColor = Color3.fromRGB(255, 0, 0)
    
        player.PlayerGui.ChildAdded:Connect(function(child)
            if child.Name == "BallGui" then
                local disp = child:WaitForChild("Frame"):WaitForChild("Disp")
                disp.Changed:Connect(function()
                    realpower = tonumber(disp.Text)
                end)
            end
        end)
     
        while true do
            runService.RenderStepped:Wait()
            pcall(function()
                if not locked then
                    target = findtarget()
                end
                gui.Enabled = player.PlayerGui:FindFirstChild("BallGui") and enabled
                if target and enabled and player.PlayerGui:FindFirstChild("BallGui") then
                    local position, onScreen = workspace.CurrentCamera:WorldToViewportPoint(target.HumanoidRootPart.Position)
                    local power = findPower(target.Head.Position)
                    local moveDirection = getMoveDirection(target)
                    local assumedDirection = (target.Head.Position - player.Character.Head.Position).Unit
                    local speed = (assumedDirection * power).Magnitude
                    local t = ((target.Head.Position - player.Character.Head.Position).Magnitude / speed) * (angle / 22)
                    local velocity, dir, pwr = calculateVelocity(player.Character.Head.Position + assumedDirection * 5, target.Head.Position + (moveDirection * 22.5 * t) + moveDirection * leadDistance, t)
                    highlight.Parent = target
                    upower = math.clamp(pwr, 0, 95)
                    udirection = dir
                    sphere.Transparency = 0
                    gui.Player.PlayerText.Text = target.Name
                    sphere.Position = calculateLanding(upower, udirection)
                    if onScreen then
                        line.Visible = false
                        line.From = workspace.CurrentCamera:WorldToViewportPoint(player.Character.Football.Handle.Position)
                        line.To = Vector2.new(position.X, position.Y)
                    else
                        line.Visible = false
                    end
                else
                    line.Visible = true
                    highlight.Parent = nil
                    sphere.Transparency = 1
                end
            end)
        end
    end)
    end
    })
 
    
    
    local Toggle = Tab:CreateToggle({
        Name = "angle qb",
        CurrentValue = false,
        Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
        Callback = function(state)
    autoAngle = v
    end
    })


local players = game:GetService("Players")
local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local remotes = replicatedStorage:FindFirstChild("Remotes")
local characterSoundEvent = remotes:FindFirstChild("CharacterSoundEvent")
local player = players.LocalPlayer
local runService = game:GetService("RunService")

local blatant = 0
local universal = 0
local uis = game:GetService("UserInputService")
local uniDelay = 0
local regDelay = 0
--Regular
-- Functions

local Players = game:GetService("Players")
local Mouse = Players.LocalPlayer:GetMouse()
local numTeleports = 30 -- Define the number of teleports
local tooggleEnabled = false -- Variable to track the toggle state

local function universalcatch()
	if tooggleEnabled then
		local catchRight = Players.LocalPlayer.Character:FindFirstChild("CatchRight")

		if not catchRight then
			return
		end

		local closestFootball = nil
		local closestDistance = math.huge

		for i, v in pairs(game.Workspace:GetDescendants()) do
			if v.Name == "Football" and v:IsA("BasePart") then
				local distance = (v.Position - catchRight.Position).Magnitude
				if distance < closestDistance and distance <= universal then
					v.CanCollide = false
					closestDistance = distance
					closestFootball = v
				end
			end
		end

		if closestFootball then
				wait(uniDelay)
			firetouchinterest(game.Players.LocalPlayer.Character["CatchRight"], closestFootball, 0)
			firetouchinterest(game.Players.LocalPlayer.Character["CatchRight"], closestFootball, 0)
			firetouchinterest(game.Players.LocalPlayer.Character["CatchRight"], closestFootball, 1)
			firetouchinterest(game.Players.LocalPlayer.Character["CatchRight"], closestFootball, 1)
			task.wait()
		end
	end
end


--ballgui





-- Start
--    local player = game.Players.LocalPlayer
local plr = game.Players.LocalPlayer
local rs = game:GetService("RunService")


local Toggle = Tab1:CreateToggle({
    Name = "uni mags",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(v)
        tooggleEnabled = v
        if v then
            spawn(function()
                while tooggleEnabled do
                    universalcatch()
                    task.wait() -- Let the thread yield to prevent blocking
                end
            end)
        end
    end
})



local Slider = Tab1:CreateSlider({
	Name = "Universal Delay",
	Range = {0, 1},
	Increment = 0.1,
	Suffix = "mag delay",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(v)
	uniDelay = v
end})

local Slider = Tab1:CreateSlider({
	Name = "Universal Range",
	Range = {0, 60},
	Increment = 1,
	Suffix = "mag range",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(v)
	universal = v
end})



local teleportationConnection = nil
local regtog = false -- Initialize regtog here

local Toggle = Tab1:CreateToggle({
    Name = "emulator mags",
    CurrentValue = false,
    Callback = function(v)
        regtog = v
        if regtog then
            -- Start the teleportation if the toggle is turned on
            teleportToClosestFootball()
        else
            -- Stop the teleportation if the toggle is turned off
            stopTeleportation()
        end
    end
})

-- Define the function to handle input and teleportation
local function handleInput(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local catchLeft = Players.LocalPlayer.Character:FindFirstChild("CatchLeft")

        if not catchLeft then
            return
        end

        local closestFootball = nil
        local closestDistance = math.huge

        for i, v in pairs(game.Workspace:GetDescendants()) do
            if v.Name == "Football" and v:IsA("BasePart") then
                local distance = (v.Position - catchLeft.Position).Magnitude
                if distance < closestDistance and distance <= blatant then
                    v.CanCollide = false
                    closestDistance = distance
                    closestFootball = v
                end
            end
        end

        -- Teleport the closest football if found
        if closestFootball then
            for _ = 1, numTeleports do
                if regtog then
                    wait(regDelay)
                    local tweenService = game:GetService("TweenService")
                    local tweenInfo = TweenInfo.new(.05, Enum.EasingStyle.Quad)
                    tweenService:Create(closestFootball, tweenInfo, {CFrame = catchLeft.CFrame}):Play()
                    wait()
                end
            end
        end
    end
end

-- Define the function to start teleportation
function teleportToClosestFootball()
    -- Connect the input handling function to the input event
    teleportationConnection = uis.InputBegan:Connect(handleInput)
end

-- Define the function to stop teleportation
function stopTeleportation()
    -- Disconnect the input event connection if it exists
    if teleportationConnection then
        teleportationConnection:Disconnect()
        teleportationConnection = nil
    end
end



local Slider = Tab1:CreateSlider({
	Name = "emulator mags",
	Range = {0, 1},
	Increment = 0.1,
	Suffix = "mag delay",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(v)
	regDelay = v
end})

local Slider = Tab1:CreateSlider({
	Name = "emulator mags",
	Range = {0, 100},
	Increment = 1,
	Suffix = "mag range",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(v)
	blatant = v
end})







local Button = Tab2:CreateButton({
	Name = "tp to home endzone",
	Callback = function()
        local Teleport1 = function(XP, YP, ZP)
		local XTpEvery = 8
		local YTpEvery = 1
		local ZTpEvery = 8
		local Timer = 0.2
		local pos = game:GetService('Players').LocalPlayer.Character.HumanoidRootPart
		if pos.Position.X < XP then
			for x = pos.Position.X, XP, XTpEvery do
				game.Players.LocalPlayer.Character:MoveTo(Vector3.new(x, pos.Position.Y, pos.Position.Z))
				local part = Instance.new("Part", workspace)
				part.Anchored = true
				part.Size = Vector3.new(10, 0.1, 10)
				part.Material = "Glass"
				part.BrickColor = BrickColor.Random()
				part.Transparency = 1
				part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
				wait(Timer)
				part:Destroy()
			end
		else
			for x = pos.Position.X, XP, -XTpEvery do
				game.Players.LocalPlayer.Character:MoveTo(Vector3.new(x, pos.Position.Y, pos.Position.Z))
				local part = Instance.new("Part", workspace)
				part.Anchored = true
				part.Size = Vector3.new(10, 0.1, 10)
				part.Material = "Glass"
				part.BrickColor = BrickColor.Random()
				part.Transparency = 1
				part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
				wait(Timer)
				part:Destroy()
			end
		end
		if pos.Position.Z < ZP then
			for z = pos.Position.Z, ZP, ZTpEvery do
				game.Players.LocalPlayer.Character:MoveTo(Vector3.new(pos.Position.X, pos.Position.Y, z))
				local part = Instance.new("Part", workspace)
				part.Anchored = true
				part.Size = Vector3.new(10, 0.1, 10)
				part.Material = "Glass"
				part.BrickColor = BrickColor.Random()
				part.Transparency = 1
				part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
				wait(Timer)
				part:Destroy()
			end
		else
			for z = pos.Position.Z, ZP, -ZTpEvery do
				game.Players.LocalPlayer.Character:MoveTo(Vector3.new(pos.Position.X, pos.Position.Y, z))
				local part = Instance.new("Part", workspace)
				part.Anchored = true
				part.Size = Vector3.new(10, 0.1, 10)
				part.Material = "Glass"
				part.BrickColor = BrickColor.Random()
				part.Transparency = 1
				part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
				wait(Timer)
				part:Destroy()
			end
		end
		if pos.Position.Y < YP then
			for High = pos.Position.Y, YP, YTpEvery do
				game.Players.LocalPlayer.Character:MoveTo(Vector3.new(pos.Position.X, High, pos.Position.Z))
				local part = Instance.new("Part", workspace)
				part.Anchored = true
				part.Size = Vector3.new(10, 0.1, 10)
				part.Material = "Glass"
				part.BrickColor = BrickColor.Random()
				part.Transparency = 1
				part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
				wait(Timer)
				part:Destroy()
			end
		else
			for High = pos.Position.Y, YP, -YTpEvery do
				game.Players.LocalPlayer.Character:MoveTo(Vector3.new(pos.Position.X, High, pos.Position.Z))
				local part = Instance.new("Part", workspace)
				part.Anchored = true
				part.Size = Vector3.new(10, 0.1, 10)
				part.Material = "Glass"
				part.BrickColor = BrickColor.Random()
				part.Transparency = 1
				part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
				wait(Timer)
				part:Destroy()
			end
		end
		game.Players.LocalPlayer.Character:MoveTo(Vector3.new(XP, YP, ZP))
	end

	Teleport1(2, 6, -169)
end})

local Button = Tab2:CreateButton({
	Name = "tp to away endzone",
	Callback = function()
		local Teleport1 = function(XP, YP, ZP)
			local XTpEvery = 8
			local YTpEvery = 1
			local ZTpEvery = 8
			local Timer = 0.2
			local pos = game:GetService('Players').LocalPlayer.Character.HumanoidRootPart
			if pos.Position.X < XP then
				for x = pos.Position.X, XP, XTpEvery do
					game.Players.LocalPlayer.Character:MoveTo(Vector3.new(x, pos.Position.Y, pos.Position.Z))
					local part = Instance.new("Part", workspace)
					part.Anchored = true
					part.Size = Vector3.new(10, 0.1, 10)
					part.Material = "Glass"
					part.BrickColor = BrickColor.Random()
					part.Transparency = 1
					part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
					wait(Timer)
					part:Destroy()
				end
			else
				for x = pos.Position.X, XP, -XTpEvery do
					game.Players.LocalPlayer.Character:MoveTo(Vector3.new(x, pos.Position.Y, pos.Position.Z))
					local part = Instance.new("Part", workspace)
					part.Anchored = true
					part.Size = Vector3.new(10, 0.1, 10)
					part.Material = "Glass"
					part.BrickColor = BrickColor.Random()
					part.Transparency = 1
					part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
					wait(Timer)
					part:Destroy()
				end
			end
			if pos.Position.Z < ZP then
				for z = pos.Position.Z, ZP, ZTpEvery do
					game.Players.LocalPlayer.Character:MoveTo(Vector3.new(pos.Position.X, pos.Position.Y, z))
					local part = Instance.new("Part", workspace)
					part.Anchored = true
					part.Size = Vector3.new(10, 0.1, 10)
					part.Material = "Glass"
					part.BrickColor = BrickColor.Random()
					part.Transparency = 1
					part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
					wait(Timer)
					part:Destroy()
				end
			else
				for z = pos.Position.Z, ZP, -ZTpEvery do
					game.Players.LocalPlayer.Character:MoveTo(Vector3.new(pos.Position.X, pos.Position.Y, z))
					local part = Instance.new("Part", workspace)
					part.Anchored = true
					part.Size = Vector3.new(10, 0.1, 10)
					part.Material = "Glass"
					part.BrickColor = BrickColor.Random()
					part.Transparency = 1
					part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
					wait(Timer)
					part:Destroy()
				end
			end
			if pos.Position.Y < YP then
				for High = pos.Position.Y, YP, YTpEvery do
					game.Players.LocalPlayer.Character:MoveTo(Vector3.new(pos.Position.X, High, pos.Position.Z))
					local part = Instance.new("Part", workspace)
					part.Anchored = true
					part.Size = Vector3.new(10, 0.1, 10)
					part.Material = "Glass"
					part.BrickColor = BrickColor.Random()
					part.Transparency = 1
					part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
					wait(Timer)
					part:Destroy()
				end
			else
				for High = pos.Position.Y, YP, -YTpEvery do
					game.Players.LocalPlayer.Character:MoveTo(Vector3.new(pos.Position.X, High, pos.Position.Z))
					local part = Instance.new("Part", workspace)
					part.Anchored = true
					part.Size = Vector3.new(10, 0.1, 10)
					part.Material = "Glass"
					part.BrickColor = BrickColor.Random()
					part.Transparency = 1
					part.Position = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, -3.05, 0)
					wait(Timer)
					part:Destroy()
				end
			end
			game.Players.LocalPlayer.Character:MoveTo(Vector3.new(XP, YP, ZP))
		end

		Teleport1(-0, 6, 164)
	end})


    local Button = Tab2:CreateButton({
        Name = "finish cap race",
        Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Workspace").Models.LockerRoomA.FinishLine.CFrame + Vector3.new(0, 2, 0)
    end})



    local autokick = false 

task.spawn(function()

getgenv().Variables = {}

	Variables.Players = game:GetService("Players")
	Variables.ReplicatedStorage = game:GetService("ReplicatedStorage")
	Variables.UserInputService = game:GetService("UserInputService")
	Variables.Client = Variables.Players.LocalPlayer
	Variables.Character = Variables.Client.Character or Variables.Client.CharacterAdded:Wait()

	Variables.Client.CharacterAdded:Connect(function(Character)
		Variables.Character = Character 
	end)

	local Aimbot = {}

	function Aimbot:GetAccuracyArrow(Arrows)
		local Y = 0
		local Arrow1 = nil

		for _, Arrow in pairs(Arrows) do
			if Arrow.Position.Y.Scale > Y then
				Y = Arrow.Position.Y.Scale
				Arrow1 = Arrow 
			end
		end

		return Arrow1
	end

	Variables.Client.PlayerGui.ChildAdded:Connect(function(child)
		if child.Name == "KickerGui" and autokick == true then
			local KickerGui = child 
			local Meter = KickerGui:FindFirstChild("Meter")
			local Cursor = Meter:FindFirstChild("Cursor")
			local Arrows = {}

			for i,v in pairs(Meter:GetChildren()) do
				if string.find(v.Name:lower(), "arrow") then
					table.insert(Arrows, v)
				end
			end 

			repeat task.wait() until Cursor.Position.Y.Scale < 0.02
			mouse1click()
			repeat task.wait() until Cursor.Position.Y.Scale >= Aimbot:GetAccuracyArrow(Arrows).Position.Y.Scale + (.03 / (100 / 100))
			mouse1click()
		end
	end)
end)

local Toggle = Tab3:CreateToggle({
    Name = "kicker aimbot",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(v)
	autokick = v
end})


local connection

local Toggle = Tab4:CreateToggle({
    Name = "tp tackle",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(v)
	if v then
		connection = game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()
			for i, v in pairs(game.workspace:GetDescendants()) do
				if v.Name == "Football" and v:IsA("Tool") then
					local toolPosition = v.Parent.HumanoidRootPart.Position
					local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
					if (toolPosition - playerPosition).Magnitude <= tprange then
						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v.Parent.HumanoidRootPart.CFrame + Vector3.new(1, 1, 1)
					end
				end
			end
		end)
	else
		if connection then
			connection:Disconnect() -- Disconnect the mouse click event only if it exists
		end
	end
end})

local Slider = Tab4:CreateSlider({
	Name = "click tackle tp range",
	Range = {1, 15},
	Increment = 1,
	Suffix = "mag range",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(v)
	tprange = v
end})




local swatreachmain = false
local player = game.Players.LocalPlayer
local swatDistance = math.huge
local swatted = false
local userInputService = game:GetService("UserInputService")

local function isFootball(fb)
	return fb and fb:FindFirstChildWhichIsA("RemoteEvent")
end

local function getNearestBall(checkFunc)
	local lowestDistance = math.huge
	local lowestFB = nil
	for index, part in pairs(workspace:GetChildren()) do
		if isFootball(part) and not part.Anchored then
			if checkFunc then
				if not checkFunc(part) then
					continue
				end
			end
			local distance = (player.Character.HumanoidRootPart.Position - part.Position).Magnitude
			if distance < lowestDistance then
				lowestFB = part
				lowestDistance = distance
			end
		end
	end
	return lowestFB, lowestDistance
end

local function getNearestPartToPartFromParts(parts, part)
	local lowestMagnitude = math.huge
	local lowestPart = nil
	for index, p in pairs(parts) do
		local dis = (part.Position - p.Position).Magnitude
		if dis < lowestMagnitude then
			lowestMagnitude = dis
			lowestPart = p
		end
	end
	return lowestPart
end

local function initCharacter(char)
	while swatreachmain do
		task.wait()
		local ball = getNearestBall()
		if ball and swatted then
			local distance = (player.Character.HumanoidRootPart.Position - ball.Position).Magnitude
			if distance < swatDistance then
				local catch = getNearestPartToPartFromParts({player.Character["CatchLeft"], player.Character["CatchRight"]}, ball)
				firetouchinterest(ball, catch, 0)
				firetouchinterest(ball, catch, 1)
			end
		end
	end
end

userInputService.InputBegan:Connect(function(input, gp)
	if not gp then
		if input.KeyCode == Enum.KeyCode.R and not swatted then
			swatted = true
			task.wait(1.5)
			swatted = false
		end
	end
end)

local function updateCharacter(character)
	if swatreachmain then
		initCharacter(character)
	end
end

player.CharacterAdded:Connect(updateCharacter)
--slider
local Toggle = Tab4:CreateToggle({
    Name = "swat reach",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(value)
	swatreachmain = value
	if value then
		updateCharacter(player.Character) 
	end
end})

if swatreachmain then
	initCharacter(player.Character)
end

-- Auto Swat

local autoswatv = 0

local enabledd = false

local function autoswatfunction()
	if enabledd then
		local player = game.Players.LocalPlayer
		local character = player.Character or player.CharacterAdded:Wait()
		local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
		local RunService = game:GetService("RunService")

		local function checkDistance(part)
			local distance = (part.Position - humanoidRootPart.Position).Magnitude
			if distance <= autoswatv then
				keypress(0x52)
				keyrelease(0x52)
				task.wait()
			end
		end
		local function updateDistances()
			for _, v in pairs(game.Workspace:GetDescendants()) do
				if v.Name == "Football" and v:IsA("BasePart") then
					checkDistance(v)
				end
			end
		end
		connection = RunService.Heartbeat:Connect(updateDistances)
	else
		if connection then
			connection:Disconnect()
			connection = nil
		end
	end
end
--uni
local Toggle = Tab4:CreateToggle({
    Name = "auto swat",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(v)
	enabledd = v
	autoswatfunction()
end})

local Slider = Tab4:CreateSlider({
	Name = "swat reach kinda laggy",
	Range = {1, 45},
	Increment = 1,
	Suffix = "swat reach",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(v)
	autoswatv = v
end})




local Toggle = Tab1:CreateToggle({
    Name = "predicted jump locations",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(v)
	if v then
		local player = game.Players.LocalPlayer

		local function handleBall(ball)
			if ball.Name == "Football" and ball:IsA("BasePart") then
				local v0 = ball.Velocity
				local x0 = ball.Position
				local dt = 1/30
				local grav = Vector3.new(0, -28, 0)
				local points = {
					[1] = x0
				}
				local function check(p, v0)
					local raycastParams = RaycastParams.new()
					raycastParams.RespectCanCollide = true
					local ray = workspace:Raycast(p, Vector3.new(0, -1000, 0), raycastParams)
					local ray2 = workspace:Raycast(p, Vector3.new(0, -7.2 * 2, 0), raycastParams)
					return ray and not ray2
				end
				while true do
					if not check(points[#points], v0) then
						if v0.Y < 0 then
							break
						end
					end
					local currentPoint = points[#points]
					v0 += grav * dt
					points[#points + 1] = currentPoint + (v0 * dt)
				end
				local optimal = points[#points]
				local part = Instance.new("Part")
				part.Anchored = true
				part.CanCollide = false
				part.Position = Vector3.new(optimal.X, player.Character.HumanoidRootPart.Position.Y + 1.5, optimal.Z)
				part.Parent = workspace
				part.Material = Enum.Material.Neon
				part.Size = Vector3.new(1.5, 1.5, 1.5)
				repeat task.wait() until ball.Parent ~= workspace
				part:Destroy()
			end
		end

		local function handleChildAdded(ball)
			task.wait()
			handleBall(ball)
		end
		eventConnection = workspace.ChildAdded:Connect(handleChildAdded)
	else
		if eventConnection then
			eventConnection:Disconnect()
			eventConnection = nil
		end
	end
end})





local function beamProjectile(g, v0, x0, t1) -- easy egomoose copy!
    -- calculate the bezier points
    local c = 0.5*0.5*0.5;
    local p3 = 0.5*g*t1*t1 + v0*t1 + x0;
    local p2 = p3 - (g*t1*t1 + v0*t1)/3;
    local p1 = (c*g*t1*t1 + 0.5*v0*t1 + x0 - c*(x0+p3))/(3*c) - p2;

    -- the curve sizes
    local curve0 = (p1 - x0).magnitude;
    local curve1 = (p2 - p3).magnitude;

    -- build the world CFrames for the attachments
    local b = (x0 - p3).unit;
    local r1 = (p1 - x0).unit;
    local u1 = r1:Cross(b).unit;
    local r2 = (p2 - p3).unit;
    local u2 = r2:Cross(b).unit;
    b = u1:Cross(r1).unit;

    local cf1 = CFrame.new(
        x0.x, x0.y, x0.z,
        r1.x, u1.x, b.x,
        r1.y, u1.y, b.y,
        r1.z, u1.z, b.z
    )

    local cf2 = CFrame.new(
        p3.x, p3.y, p3.z,
        r2.x, u2.x, b.x,
        r2.y, u2.y, b.y,
        r2.z, u2.z, b.z
    )

    return curve0, -curve1, cf1, cf2;
end







--qb

--FindTarget
local Toggle = Tab:CreateToggle({
    Name = "football landing predictions",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(v)
	if v and not toggleActive then
		toggleActive = true
		eventConnection = workspace.ChildAdded:Connect(function(b)
			if b.Name == "Football" and b:IsA("BasePart") then
				task.wait()
				local vel = b.Velocity
				local pos = b.Position
				local c0, c1, cf1, cf2 = beamProjectile(Vector3.new(0, -28, 0), vel, pos, 10)
				local beam = Instance.new("Beam")
				local a0 = Instance.new("Attachment")
				local a1 = Instance.new("Attachment")
				beam.Color = ColorSequence.new(predictioncolor)
				beam.Transparency = NumberSequence.new(0, 0)
				beam.CurveSize0 = c0
				beam.CurveSize1 = c1
				beam.Name = "Hitbox"
				beam.Parent = workspace.Terrain
				beam.Transparency = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 1),
					NumberSequenceKeypoint.new(0.01, 0),
					NumberSequenceKeypoint.new(1, 0),
					NumberSequenceKeypoint.new(1, 0.01),
				})
				beam.Segments = 1750
				a0.Parent = workspace.Terrain
				a1.Parent = workspace.Terrain
				a0.CFrame = a0.Parent.CFrame:Inverse() * cf1
				a1.CFrame = a1.Parent.CFrame:Inverse() * cf2
				beam.Attachment0 = a0
				beam.Attachment1 = a1
				beam.Width0 = 0.5
				beam.Width1 = 0.5
				repeat task.wait() until b.Parent ~= workspace
				a0:Destroy()
				a1:Destroy()
			end
		end)
	elseif not Value and toggleActive then
		toggleActive = false
		if eventConnection then
			eventConnection:Disconnect()
		end
	end
end})











local qbaimpred = false
local Toggle = Tab:CreateToggle({
    Name = "qb aim pred THIS WAS HARD ASF",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(v)
	qbaimpred = v -- Update the toggle state

	if qbaimpred then
		local beam = Instance.new("Beam")
		local a0 = Instance.new("Attachment")
		local a1 = Instance.new("Attachment")   
		local mouse = game.Players.LocalPlayer:GetMouse()
		beam.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
		beam.Transparency = NumberSequence.new(0, 0)
		beam.Segments = 10 * 300
		beam.Name = "Hitbox"
		beam.Parent = workspace.Terrain
		a0.Parent = workspace.Terrain
		a1.Parent = workspace.Terrain
		beam.Attachment0 = a0
		beam.Attachment1 = a1
		beam.Width0 = 0.5
		beam.Width1 = 0.5
		while qbaimpred do
			task.wait()
			if game.Players.LocalPlayer.Character:FindFirstChild("Football") and game.Players.LocalPlayer.PlayerGui:FindFirstChild("BallGui") and game.Players.LocalPlayer.Character:FindFirstChild("Head") then
				local power = tonumber(game.Players.LocalPlayer.PlayerGui.BallGui.Frame.Disp.Text)
				local direction = (mouse.Hit.Position - workspace.CurrentCamera.CFrame.Position).Unit
				local vel = power * direction
				local origin = game.Players.LocalPlayer.Character.Head.Position + direction * 5
				local c0, c1, cf1, cf2 = beamProjectile(Vector3.new(0, -28, 0), vel, origin, 15)
				a0.CFrame = a0.Parent.CFrame:Inverse() * cf1
				a1.CFrame = a1.Parent.CFrame:Inverse() * cf2
				beam.CurveSize0 = c0
				beam.CurveSize1 = c1
			end
		end
		beam:Destroy() -- Clean up the beam when toggled off
	else
		-- Toggle turned off
		-- Add any additional code here to handle the toggle turning off
	end
end})







local isAntiJamEnabled = false

local function updateCollisionState()
	while true do
		if isAntiJamEnabled then
			if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Head") and game.Players.LocalPlayer.Character.Head.CanCollide then
				for _, player in ipairs(game.Players:GetPlayers()) do
					if player ~= game.Players.LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
						pcall(function()
							player.Character.Torso.CanCollide = false
							player.Character.Head.CanCollide = false
						end)
					end
				end
			end
		else
			if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Head") and not game.Players.LocalPlayer.Character.Head.CanCollide then
				game.Players.LocalPlayer.Character.Torso.CanCollide = true
				game.Players.LocalPlayer.Character.Head.CanCollide = true
			end
		end
		task.wait()
	end
end

local Toggle = Tab1:CreateToggle({
    Name = "anti jam",
    CurrentValue = false,
    Flag = "Toggle1", 
    Callback = function(enabled)
        isAntiJamEnabled = enabled
    end
})





local AutoFollowQb = false
local followCarrierTask

local function FollowCarrier()
    while AutoFollowQb do
        local carrier = game:GetService("ReplicatedStorage").Values.Carrier.Value
        if carrier and carrier:IsDescendantOf(game.Players) and carrier.Team ~= game.Players.LocalPlayer.Team then
            local humanoid = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid:MoveTo(carrier.Character.Torso.Position)
            end
        end
        wait()
    end
end

local function ToggleFollowCarrier(value)
    AutoFollowQb = value
    if value then
        followCarrierTask = task.spawn(FollowCarrier)
    else
        if followCarrierTask then
            followCarrierTask:cancel()
        end
    end
end

local Toggle = Tab4:CreateToggle({
    Name = "auto follow qb",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = ToggleFollowCarrier,
})



local Slider = Tab4:CreateSlider({
	Name = "auto follow distance",
	Range = {0, 30},
	Increment = 1,
	Suffix = "distance to follow qb",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(set)

end,
})




local player = game.Players.LocalPlayer
local userInputService = game:GetService("UserInputService")
local runService = game:GetService("RunService")

local jumpCooldown = 0.5  -- Adjust this value based on your game's mechanics
local lastJumpTime = 0
local antiAceEnabled = false  -- Initial state of the anti ace toggle

local function PerformJump()
    -- Perform the jump action
    -- You might want to adjust the code here to simulate jumping
end

local function PerformDive()
    -- Perform the dive action
    -- You might want to adjust the code here to simulate diving
end

userInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
        if antiAceEnabled then
            local currentTime = tick()
            if currentTime - lastJumpTime > jumpCooldown then
                PerformJump()
                lastJumpTime = currentTime
            else
                PerformDive()
            end
        else
            -- Perform the default jump or dive action
        end
    end
end)

runService.RenderStepped:Connect(function()
    if antiAceEnabled then
        -- Check for the appropriate condition to trigger the automatic dive
        -- For example, if you detect that the character is in mid-air and has jumped
        -- Implement the automatic dive action here
    end
end)

local Toggle = Tab5:CreateToggle({
    Name = "anti ace",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(state)
        antiAceEnabled = state
    end,
})



local player = game.Players.LocalPlayer
local runService = game:GetService("RunService")

local lagEffectEnabled = false  -- Initial state of the lag effect toggle
local lagMultiplier = 0.5  -- Adjust this value to control the lag effect strength

local function ApplyLagEffect()
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                local currentVelocity = rootPart.Velocity
                rootPart.Velocity = currentVelocity * lagMultiplier
            end
        end
    end
end

runService.RenderStepped:Connect(function()
    if lagEffectEnabled then
        ApplyLagEffect()
    end
end)

local Toggle = Tab1:CreateToggle({
    Name = "makes you look laggy for ms",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(state)
        lagEffectEnabled = state
    end,
})

local Slider = Tab1:CreateSlider({
	Name = "lag adjust",
	Range = {0, 1},
	Increment = 0.1,
	Suffix = "lag",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(value)
        lagMultiplier = value
    end,
})








local UserInputService = game:GetService("UserInputService")
local JumpPowerMultiplier = 1.5  -- Default jump height multiplier
local OriginalJumpPower = game.Players.LocalPlayer.Character.Humanoid.JumpPower
local JumpToggleEnabled = false

local function OnJumpRequest(actionName, inputState, inputObject)
    if inputState == Enum.UserInputState.Begin then
        local character = game.Players.LocalPlayer.Character
        local humanoid = character and character:FindFirstChild("Humanoid")
        
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Physics)
            humanoid:Move(Vector3.new(0, humanoid.JumpPower, 0))  -- Perform a standard jump
        end
    end
end

local Toggle = Tab2:CreateToggle({
    Name = "JUMP BOOST",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(state)
        JumpToggleEnabled = state
        local character = game.Players.LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.JumpPower = state and OriginalJumpPower * JumpPowerMultiplier or OriginalJumpPower
            end
        end
    end,
})

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and JumpToggleEnabled and input.KeyCode == Enum.KeyCode.Space then
        OnJumpRequest()
    end
end)



local Toggle = Tab2:CreateToggle({
    Name = "enable ws",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(state)
        getgenv().Walkspeed = state
        while getgenv().Walkspeed == true do
            game:GetService("Players").LocalPlayer.Character.Humanoid.WalkSpeed = _G.SPEED
            wait()
        end
        if getgenv().Walkspeed == false then
            game:GetService("Players").LocalPlayer.Character.Humanoid.WalkSpeed = 20
        end
    end,
})

local Toggle = Tab2:CreateToggle({
    Name = "enable jp",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(state)
        getgenv().JP = state
        while getgenv().JP == true do
            game:GetService("Players").LocalPlayer.Character.Humanoid.JumpPower = _G.Jump
            wait()
        end
        if getgenv().JP == false then
            game:GetService("Players").LocalPlayer.Character.Humanoid.JumpPower = 50
        end
    end,
})



local Slider = Tab2:CreateSlider({
	Name = "WS adjust",
	Range = {22, 32},
	Increment = 1,
	Suffix = "ws",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(value)
        _G.SPEED = value
    end,
})

local Slider = Tab2:CreateSlider({
	Name = "JP adjust",
	Range = {50, 65},
	Increment = 1,
	Suffix = "jp",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(value)
        _G.Jump = value
    end,
})


local Toggle = Tab:CreateToggle({
    Name = "auto qb",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(data)
        local blacklisted = {"KICKOFF", "PUNT", "PAT"}
        while true do
            task.wait(1/30)
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and replicatedStorage.Values:FindFirstChild("Status") and replicatedStorage.Values.Status.Value == "PrePlay" and workspace:FindFirstChild("Football") and data.Enabled and not table.find(blacklisted, replicatedStorage.Values.StatusTag.Value) and replicatedStorage.Values.PossessionTag.Value == player.Team.Name then
                player.Character.HumanoidRootPart.CFrame = workspace:FindFirstChild("Football").CFrame
                repeat task.wait() until not workspace:FindFirstChild("Football")
            end
        end
    end
})





--button

local Button = Tab5:CreateButton({
	Name = "fps boost",
	Callback = function(state)
        
local decalsyeeted = true -- Leaving this on makes games look shitty but the fps goes up by at least 20.
local g = game
local w = g.Workspace
local l = g.Lighting
local t = w.Terrain
t.WaterWaveSize = 0
t.WaterWaveSpeed = 0
t.WaterReflectance = 0
t.WaterTransparency = 0
l.GlobalShadows = false
l.FogEnd = 9e9
l.Brightness = 0
settings().Rendering.QualityLevel = "Level01"
for i, v in pairs(g:GetDescendants()) do
    if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
    elseif v:IsA("Decal") or v:IsA("Texture") and decalsyeeted then
        v.Transparency = 1
    elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
        v.Lifetime = NumberRange.new(0)
    elseif v:IsA("Explosion") then
        v.BlastPressure = 1
        v.BlastRadius = 1
    elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") then
        v.Enabled = false
    elseif v:IsA("MeshPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
        v.TextureID = 10385902758728957
    end
end
for i, e in pairs(l:GetChildren()) do
    if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
        e.Enabled = false
    end
end

    end,
})






local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local moveDistance = 5
local isEnabled = false


local function moveCharacter()
    local newPosition = character.PrimaryPart.Position + character.PrimaryPart.CFrame.lookVector * moveDistance
    character:SetPrimaryPartCFrame(CFrame.new(newPosition))
end


local function toggleCallback(value)
    isEnabled = value
end


local function onKeyPress(input)
    if isEnabled and input.KeyCode == Enum.KeyCode.F then
        moveCharacter()
    end
end

local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(onKeyPress)


local Toggle = Tab5:CreateToggle({
    Name = "F to Quick tp good for plays",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = toggleCallback
})



local autokick = false

task.spawn(function()
    getgenv().Variables = {}

    Variables.Players = game:GetService("Players")
    Variables.ReplicatedStorage = game:GetService("ReplicatedStorage")
    Variables.UserInputService = game:GetService("UserInputService")
    Variables.Client = Variables.Players.LocalPlayer
    Variables.Character = Variables.Client.Character or Variables.Client.CharacterAdded:Wait()

    Variables.Client.CharacterAdded:Connect(function(Character)
        Variables.Character = Character
    end)

    local Aimbot = {}

    function Aimbot:GetAccuracyArrow(Arrows)
        local Y = 0
        local Arrow1 = nil

        for _, Arrow in pairs(Arrows) do
            if Arrow.Position.Y.Scale > Y then
                Y = Arrow.Position.Y.Scale
                Arrow1 = Arrow
            end
        end

        return Arrow1
    end

    Variables.Client.PlayerGui.ChildAdded:Connect(function(child)
        if child.Name == "KickerGui" and autokick == true then
            local KickerGui = child
            local Meter = KickerGui:FindFirstChild("Meter")
            local Cursor = Meter:FindFirstChild("Cursor")
            local Arrows = {}

            for i, v in pairs(Meter:GetChildren()) do
                if string.find(v.Name:lower(), "arrow") then
                    table.insert(Arrows, v)
                end
            end

            repeat
                task.wait()
            until Cursor.Position.Y.Scale < 0.02
            mouse1click()
            repeat
                task.wait()
            until Cursor.Position.Y.Scale >= Aimbot:GetAccuracyArrow(Arrows).Position.Y.Scale + (.03 / (100 / 100))
            mouse1click()
        end
    end)
end)

local Toggle = Tab3:CreateToggle({
    Name = "kick aimbot with accuracy",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(state)
        autokick = state
    end
})

local Slider = Tab3:CreateSlider({
	Name = "accuracy",
	Range = {0, 5},
	Increment = 1,
	Suffix = "kicker accuracy",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(value)
        PerfectKick = v
    end
})



	local block = false
local blockslider = 1.5
local defaultSize = Vector3.new(0.75, 5, 1.5)

local function setBlockSize()
    if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("BlockPart") then
        game.Players.LocalPlayer.Character.BlockPart.Size = Vector3.new(blockslider, 5, blockslider)
    end
end

local Toggle = Tab5:CreateToggle({
    Name = "Block reach",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(state)
        block = state
        if block then
            setBlockSize()
        else
            game.Players.LocalPlayer.Character.BlockPart.Size = defaultSize
            blockslider = 1.5
        end
    end,
})

local Slider = Tab5:CreateSlider({
	Name = "block size",
	Range = {1.5, 20},
	Increment = 0.5,
	Suffix = "block",
	CurrentValue = 0,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(set)
        blockslider = set
        if block then
            setBlockSize()
        end
    end,
})

--tackle


--runser
